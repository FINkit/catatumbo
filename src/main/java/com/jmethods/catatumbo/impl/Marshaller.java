/*
 * Copyright 2016 Sai Pullabhotla.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jmethods.catatumbo.impl;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.UUID;

import com.google.cloud.datastore.BaseEntity;
import com.google.cloud.datastore.Datastore;
import com.google.cloud.datastore.Entity;
import com.google.cloud.datastore.FullEntity;
import com.google.cloud.datastore.IncompleteKey;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.NullValue;
import com.google.cloud.datastore.Value;
import com.google.cloud.datastore.ValueBuilder;
import com.jmethods.catatumbo.DatastoreKey;
import com.jmethods.catatumbo.EntityManagerException;

/**
 * Converts application's entities (POJOs) to the format needed for the
 * underlying Cloud Datastore API.
 *
 * @author Sai Pullabhotla
 */
public class Marshaller {

	/**
	 * Reference to the Datastore object
	 */
	private final Datastore datastore;

	/**
	 * Entity being marshaled
	 */
	private final Object entity;

	/**
	 * Metadata of the entity being marshaled
	 */
	private final EntityMetadata entityMetadata;

	/**
	 * Builder for building the Entity needed for Cloud Datastore
	 */
	private BaseEntity.Builder<?, ?> entityBuilder;

	/**
	 * Key
	 */
	private IncompleteKey key;

	/**
	 * Whether or not to auto-generate key.
	 */
	private boolean doNotGenerateId = false;

	/**
	 * Creates a new instance of <code>Marshaller</code>.
	 *
	 * @param datastore
	 *            reference to the Datastore object
	 * @param entity
	 *            the Entity to marshal
	 */
	private Marshaller(Datastore datastore, Object entity) {
		this.datastore = datastore;
		this.entity = entity;
		entityMetadata = EntityIntrospector.introspect(entity.getClass());

	}

	/**
	 * Marshals the given entity (POJO) into the format needed for the low level
	 * Cloud Datastore API. If the given entity does not have a valid ID, and if
	 * the Identifier annotation is set to autoGenerate, the ID will be
	 * generated.
	 *
	 * @param datastore
	 *            the Datastore
	 * @param entity
	 *            the entity to marshal
	 * @return the marshaled object.
	 */
	public static BaseEntity<?> marshal(Datastore datastore, Object entity) {
		return marshal(datastore, entity, false);
	}

	/**
	 * Marshals the given entity (POJO) into the format needed for the low level
	 * Cloud Datastore API.
	 * 
	 * @param datastore
	 *            the Datastore
	 * @param entity
	 *            the entity to marshal
	 * @param doNotGenerateId
	 *            if ID should not be auto-generated, even if the Entity is
	 *            marked with autoGenerated ID. This is used in cases where
	 *            marshalling is needed for update or delete options, in which
	 *            case it is expected that the entity have a valid ID.
	 * @return the marshaled object
	 */
	public static BaseEntity<?> marshal(Datastore datastore, Object entity, boolean doNotGenerateId) {
		Marshaller marshaller = new Marshaller(datastore, entity);
		marshaller.doNotGenerateId = doNotGenerateId;
		return marshaller.marshal();
	}

	/**
	 * Extracts the key from the given object, entity, and returns it. Then
	 * entity must have its ID set.
	 *
	 * @param datastore
	 *            the Datastore.
	 * @param entity
	 *            the entity from which key is to be extracted
	 * @return extracted key.
	 */
	public static Key marshalKey(Datastore datastore, Object entity) {
		Marshaller marshaller = new Marshaller(datastore, entity);
		marshaller.doNotGenerateId = true;
		marshaller.marshalKey();
		return (Key) marshaller.key;
	}

	/**
	 * Marshals the given entity and and returns the equivalent Entity needed
	 * for the underlying Cloud Datastore API.
	 * 
	 * @return A native entity that is equivalent to the POJO being marshalled.
	 *         The returned value could either be a FullEntity or Entity.
	 */
	private BaseEntity<?> marshal() {
		marshalKey();
		if (key instanceof Key) {
			entityBuilder = Entity.builder((Key) key);
		} else {
			entityBuilder = FullEntity.builder(key);
		}
		marshalFields();
		return entityBuilder.build();
	}

	/**
	 * Marshals the key.
	 */
	private void marshalKey() {

		Key parent = null;

		ParentKeyMetadata parentKeyMetadata = entityMetadata.getParentKeyMetadata();
		if (parentKeyMetadata != null) {
			DatastoreKey parentDatastoreKey = (DatastoreKey) getFieldValue(parentKeyMetadata);
			if (parentDatastoreKey != null) {
				parent = parentDatastoreKey.nativeKey();
			}
		}

		IdentifierMetadata identifierMetadata = entityMetadata.getIdentifierMetadata();
		DataType identifierType = identifierMetadata.getDataType();
		Object idValue = getFieldValue(identifierMetadata);

		boolean validId = isValidId(idValue, identifierType);
		boolean autoGenerateId = identifierMetadata.isAutoGenerated();

		if (validId) {
			if (identifierType == DataType.STRING) {
				createCompleteKey(parent, (String) idValue);
			} else {
				createCompleteKey(parent, (long) idValue);
			}
		} else {
			if (doNotGenerateId) {
				throw new EntityManagerException(
						String.format("Identifier is not set or vlaid for entity of type %s", entity.getClass()));
			}
			if (!autoGenerateId) {
				throw new EntityManagerException(String.format(
						"Identifier is not set or vlaid for entity of type %s. Auto generation of ID is explicity turned off. ",
						entity.getClass()));
			} else {
				if (identifierType == DataType.STRING) {
					createCompleteKey(parent);
				} else {
					createIncompleteKey(parent);
				}
			}
		}
	}

	/**
	 * Checks to see if the given value is a valid identifier for the given ID
	 * type.
	 * 
	 * @param idValue
	 *            the ID value
	 * @param identifierType
	 *            the identifier type
	 * @return <code>true</code>, if the given value is a valid identifier;
	 *         <code>false</code>, otherwise. For STRING type, the ID is valid
	 *         if it it contains at least one printable character. In other
	 *         words, if ((String) idValue).trim().length() > 0. For numeric
	 *         types, the ID is valid if it is not <code>null</code> or zero.
	 */
	private static boolean isValidId(Object idValue, DataType identifierType) {
		boolean validId = false;
		if (idValue != null) {
			switch (identifierType) {
			case LONG:
			case LONG_OBJECT:
				validId = (long) idValue != 0;
				break;
			case STRING:
				validId = ((String) idValue).trim().length() > 0;
				break;
			default:
				// we should never get here
				break;
			}
		}
		return validId;
	}

	/**
	 * Creates a complete key using the given parameters.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 * @param id
	 *            the numeric ID
	 */
	private void createCompleteKey(Key parent, long id) {
		String kind = entityMetadata.getKind();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey(id);
		} else {
			key = Key.builder(parent, kind, id).build();
		}
	}

	/**
	 * Creates a complete key using the given parameters.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 * @param id
	 *            the String ID
	 */
	private void createCompleteKey(Key parent, String id) {
		String kind = entityMetadata.getKind();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey(id);
		} else {
			key = Key.builder(parent, kind, id).build();
		}
	}

	/**
	 * Creates a ComplteKey using the given parameters. The actual ID is
	 * generated using <code>UUID.randomUUID().toString()</code>.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 */
	private void createCompleteKey(Key parent) {
		String kind = entityMetadata.getKind();
		String id = UUID.randomUUID().toString();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey(id);
		} else {
			key = Key.builder(parent, kind, id).build();
		}
	}

	/**
	 * Creates an IncompleteKey.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 */
	private void createIncompleteKey(Key parent) {
		String kind = entityMetadata.getKind();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey();
		} else {
			key = IncompleteKey.builder(parent, kind).build();
		}
	}

	/**
	 * Marshals all the fields.
	 */
	private void marshalFields() {
		Collection<PropertyMetadata> propertyMetadataCollection = entityMetadata.getPropertyMetadataCollection();
		for (PropertyMetadata propertyMetadata : propertyMetadataCollection) {
			marshalField(propertyMetadata);
		}
	}

	/**
	 * Marshals the field with the given metadata.
	 *
	 * @param propertyMetadata
	 *            the field's metadata
	 */
	private void marshalField(PropertyMetadata propertyMetadata) {
		Object fieldValue = getFieldValue(propertyMetadata);
		ValueBuilder<?, ?, ?> valueBuilder = null;
		if (fieldValue == null) {
			valueBuilder = NullValue.builder();
		} else {
			PropertyConverter converter = propertyMetadata.getDataType().getConverter();
			valueBuilder = converter.toValueBuilder(fieldValue);
		}
		valueBuilder.excludeFromIndexes(!propertyMetadata.isIndexed());
		Value<?> datastoreValue = valueBuilder.build();
		entityBuilder.set(propertyMetadata.getMappedName(), datastoreValue);

	}

	/**
	 * Returns the field value for the given field.
	 *
	 * @param fieldMetadata
	 *            the field's metadata
	 * @return the field s value
	 */
	private Object getFieldValue(FieldMetadata fieldMetadata) {
		Method readMethod = fieldMetadata.getReadMethod();
		try {
			return readMethod.invoke(entity);
		} catch (Exception exp) {
			throw new EntityManagerException(exp.getMessage(), exp);
		}
	}

}
