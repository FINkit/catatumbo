/*
 * Copyright 2016 Sai Pullabhotla.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jmethods.catatumbo.impl;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.UUID;

import com.google.cloud.datastore.Datastore;
import com.google.cloud.datastore.DatastoreOptions;
import com.google.cloud.datastore.Entity;
import com.google.cloud.datastore.IncompleteKey;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.NullValue;
import com.google.cloud.datastore.Value;
import com.google.cloud.datastore.ValueBuilder;
import com.jmethods.catatumbo.DatastoreKey;
import com.jmethods.catatumbo.EntityManagerException;

/**
 * Converts application's entities (POJOs) to the format needed for the
 * underlying Cloud Datastore API.
 *
 * @author Sai Pullabhotla
 */
public class Marshaller {

	/**
	 * Reference to the Datastore object
	 */
	private final Datastore datastore;

	/**
	 * Entity being marshaled
	 */
	private final Object entity;

	/**
	 * Metadata of the entity being marshaled
	 */
	private final EntityMetadata entityMetadata;

	/**
	 * Builder for building the Entity needed for Cloud Datastore
	 */
	private Entity.Builder entityBuilder;

	/**
	 * Key
	 */
	private Key key;

	/**
	 * Whether or not to auto-generate key.
	 */
	private boolean doNotGenerateId = false;

	/**
	 * Creates a new instance of <code>Marshaller</code>.
	 *
	 * @param datastore
	 *            reference to the Datastore object
	 * @param entity
	 *            the Entity to marshal
	 */
	private Marshaller(Datastore datastore, Object entity) {
		this.datastore = datastore;
		this.entity = entity;
		entityMetadata = EntityIntrospector.introspect(entity.getClass());

	}

	/**
	 * Marshals the given entity (POJO) into the format needed for the low level
	 * Cloud Datastore API. If the given entity does not have a valid ID, and if
	 * the Identifier annotation is set to autoGenerate, the ID will be
	 * generated.
	 *
	 * @param datastore
	 *            the Datastore
	 * @param entity
	 *            the entity to marshal
	 * @return the marshaled object.
	 */
	public static Entity marshal(Datastore datastore, Object entity) {
		return marshal(datastore, entity, false);
	}

	/**
	 * Marshals the given entity (POJO) into the format needed for the low level
	 * Cloud Datastore API.
	 * 
	 * @param datastore
	 *            the Datastore
	 * @param entity
	 *            the entity to marshal
	 * @param doNotGenerateId
	 *            if ID should not be auto-generated, even if the Entity is
	 *            marked with autoGenerated ID. This is used in cases where
	 *            marshalling is needed for update or delete options.
	 * @return the marshaled object
	 */
	public static Entity marshal(Datastore datastore, Object entity, boolean doNotGenerateId) {
		Marshaller marshaller = new Marshaller(datastore, entity);
		marshaller.doNotGenerateId = doNotGenerateId;
		return marshaller.marshal();
	}

	/**
	 * Extracts the key from the given object, entity, and returns it.
	 *
	 * @param datastore
	 *            the Datastore.
	 * @param entity
	 *            the entity from which key is to be extracted
	 * @return extracted key.
	 */
	public static Key marshalKey(Datastore datastore, Object entity) {
		Marshaller marshaller = new Marshaller(datastore, entity);
		marshaller.doNotGenerateId = true;
		marshaller.marshalKey();
		return marshaller.key;
	}

	/**
	 * Marshals the given entity and and returns the equivalent Entity needed
	 * for the underlying Cloud Datastore API.
	 * 
	 * @return the BaseEntity
	 */
	private Entity marshal() {
		marshalKey();
		entityBuilder = Entity.builder(key);
		marshalFields();
		return entityBuilder.build();
	}

	/**
	 * Marshals the key.
	 * 
	 * @Improve
	 */
	private void marshalKey() {

		Key parent = null;

		ParentKeyMetadata parentKeyMetadata = entityMetadata.getParentKeyMetadata();
		if (parentKeyMetadata != null) {
			DatastoreKey parentDatastoreKey = (DatastoreKey) getFieldValue(parentKeyMetadata);
			if (parentDatastoreKey != null) {
				parent = parentDatastoreKey.nativeKey();
			}
		}

		IdentifierMetadata identifierMetadata = entityMetadata.getIdentifierMetadata();
		DataType identifierType = identifierMetadata.getDataType();
		Object idValue = getFieldValue(identifierMetadata);

		boolean validId = isValidId(idValue, identifierType);
		boolean autoGenerateId = identifierMetadata.isAutoGenerated();

		if (validId) {
			createCompleteKey(identifierType, parent, idValue);
		} else {
			if (doNotGenerateId) {
				throw new EntityManagerException("Identifier is not set");
			}
			if (!autoGenerateId) {
				throw new EntityManagerException("Identifier is not set and autoGenerate is false");
			} else {
				createCompleteKey(identifierType, parent);
			}
		}
	}

	private static boolean isValidId(Object keyValue, DataType identifierType) {
		boolean validId = false;
		if (keyValue != null) {
			switch (identifierType) {
			case LONG:
			case LONG_OBJECT:
				validId = (long) keyValue != 0;
				break;
			case STRING:
				validId = ((String) keyValue).trim().length() > 0;
				break;
			default:
				// we should never get here
				break;
			}
		}
		return validId;
	}

	private void createCompleteKey(DataType identifierType, Key parent, Object id) {
		Key.Builder keyBuilder = null;
		DatastoreOptions options = datastore.options();
		switch (identifierType) {
		case LONG:
		case LONG_OBJECT:
			if (parent != null) {
				keyBuilder = Key.builder(parent, entityMetadata.getKind(), (long) id);
			} else {
				keyBuilder = Key.builder(options.projectId(), entityMetadata.getKind(), (long) id);
				keyBuilder.namespace(options.namespace());
			}
			break;
		case STRING:
			if (parent != null) {
				keyBuilder = Key.builder(parent, entityMetadata.getKind(), (String) id);
			} else {
				keyBuilder = Key.builder(options.projectId(), entityMetadata.getKind(), (String) id);
				keyBuilder.namespace(options.namespace());
			}
			break;
		default:
			break;
		}
		key = keyBuilder.build();

	}

	private void createCompleteKey(DataType identifierType, Key parent) {
		IncompleteKey.Builder incompleteKeyBuilder = null;
		DatastoreOptions options = datastore.options();
		if (parent != null) {
			incompleteKeyBuilder = IncompleteKey.builder(parent, entityMetadata.getKind());
		} else {
			incompleteKeyBuilder = IncompleteKey.builder(options.projectId(), entityMetadata.getKind());
		}
		incompleteKeyBuilder.namespace(options.namespace());
		IncompleteKey incompleteKey = incompleteKeyBuilder.build();
		if (identifierType == DataType.STRING) {
			key = Key.builder(incompleteKey, UUID.randomUUID().toString()).build();
		} else {
			key = datastore.allocateId(incompleteKey);
		}
	}

	/**
	 * Marshals all the fields.
	 */
	private void marshalFields() {
		Collection<PropertyMetadata> propertyMetadataCollection = entityMetadata.getPropertyMetadataCollection();
		for (PropertyMetadata propertyMetadata : propertyMetadataCollection) {
			marshalField(propertyMetadata);
		}
	}

	/**
	 * Marshals the field with the given metadata.
	 *
	 * @param propertyMetadata
	 *            the field's metadata
	 */
	private void marshalField(PropertyMetadata propertyMetadata) {
		Object fieldValue = getFieldValue(propertyMetadata);
		ValueBuilder<?, ?, ?> valueBuilder = null;
		if (fieldValue == null) {
			valueBuilder = NullValue.builder();
		} else {
			PropertyConverter converter = propertyMetadata.getDataType().getConverter();
			valueBuilder = converter.toValueBuilder(fieldValue);
		}
		valueBuilder.excludeFromIndexes(!propertyMetadata.isIndexed());
		Value<?> datastoreValue = valueBuilder.build();
		entityBuilder.set(propertyMetadata.getMappedName(), datastoreValue);

	}

	/**
	 * Returns the field value for the given field.
	 *
	 * @param fieldMetadata
	 *            the field's metadata
	 * @return the field s value
	 */
	private Object getFieldValue(FieldMetadata fieldMetadata) {
		Method readMethod = fieldMetadata.getReadMethod();
		try {
			return readMethod.invoke(entity);
		} catch (Exception exp) {
			throw new EntityManagerException(exp.getMessage(), exp);
		}
	}

}
