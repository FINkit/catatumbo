/*
 * Copyright 2016 Sai Pullabhotla.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jmethods.catatumbo.impl;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.UUID;

import com.google.cloud.datastore.BaseEntity;
import com.google.cloud.datastore.Datastore;
import com.google.cloud.datastore.Entity;
import com.google.cloud.datastore.EntityValue;
import com.google.cloud.datastore.FullEntity;
import com.google.cloud.datastore.IncompleteKey;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.NullValue;
import com.google.cloud.datastore.Value;
import com.google.cloud.datastore.ValueBuilder;
import com.jmethods.catatumbo.DatastoreKey;
import com.jmethods.catatumbo.EntityManagerException;

/**
 * Converts application's entities (POJOs) to the format needed for the
 * underlying Cloud Datastore API.
 *
 * @author Sai Pullabhotla
 */
public class Marshaller {

	/**
	 * Reference to the Datastore object
	 */
	private final Datastore datastore;

	/**
	 * Entity being marshaled
	 */
	private final Object entity;

	/**
	 * Metadata of the entity being marshaled
	 */
	private final EntityMetadata entityMetadata;

	/**
	 * Builder for building the Entity needed for Cloud Datastore
	 */
	private BaseEntity.Builder<?, ?> entityBuilder;

	/**
	 * Key
	 */
	private IncompleteKey key;

	/**
	 * Whether or not to auto-generate key.
	 */
	private boolean doNotGenerateId = false;

	/**
	 * Creates a new instance of <code>Marshaller</code>.
	 *
	 * @param datastore
	 *            reference to the Datastore object
	 * @param entity
	 *            the Entity to marshal
	 */
	private Marshaller(Datastore datastore, Object entity) {
		this.datastore = datastore;
		this.entity = entity;
		entityMetadata = EntityIntrospector.introspect(entity.getClass());

	}

	/**
	 * Marshals the given entity (POJO) into the format needed for the low level
	 * Cloud Datastore API. If the given entity does not have a valid ID, and if
	 * the Identifier annotation is set to autoGenerate, the ID will be
	 * generated.
	 *
	 * @param datastore
	 *            the Datastore
	 * @param entity
	 *            the entity to marshal
	 * @return the marshaled object.
	 */
	@SuppressWarnings("rawtypes")
	public static BaseEntity marshal(Datastore datastore, Object entity) {
		return marshal(datastore, entity, false);
	}

	/**
	 * Marshals the given entity (POJO) into the format needed for the low level
	 * Cloud Datastore API.
	 * 
	 * @param datastore
	 *            the Datastore
	 * @param entity
	 *            the entity to marshal
	 * @param doNotGenerateId
	 *            if ID should not be auto-generated, even if the Entity is
	 *            marked with autoGenerated ID. This is used in cases where
	 *            marshalling is needed for update or delete options, in which
	 *            case it is expected that the entity have a valid ID.
	 * @return the marshaled object
	 */
	@SuppressWarnings("rawtypes")
	public static BaseEntity marshal(Datastore datastore, Object entity, boolean doNotGenerateId) {
		Marshaller marshaller = new Marshaller(datastore, entity);
		marshaller.doNotGenerateId = doNotGenerateId;
		return marshaller.marshal();
	}

	/**
	 * Extracts the key from the given object, entity, and returns it. Then
	 * entity must have its ID set.
	 *
	 * @param datastore
	 *            the Datastore.
	 * @param entity
	 *            the entity from which key is to be extracted
	 * @return extracted key.
	 */
	public static Key marshalKey(Datastore datastore, Object entity) {
		Marshaller marshaller = new Marshaller(datastore, entity);
		marshaller.doNotGenerateId = true;
		marshaller.marshalKey();
		return (Key) marshaller.key;
	}

	/**
	 * Marshals the given entity and and returns the equivalent Entity needed
	 * for the underlying Cloud Datastore API.
	 * 
	 * @return A native entity that is equivalent to the POJO being marshalled.
	 *         The returned value could either be a FullEntity or Entity.
	 */
	private BaseEntity<?> marshal() {
		marshalKey();
		if (key instanceof Key) {
			entityBuilder = Entity.builder((Key) key);
		} else {
			entityBuilder = FullEntity.builder(key);
		}
		marshalFields();
		marshalEmbeddedFields();
		return entityBuilder.build();
	}

	/**
	 * Marshals the key.
	 */
	private void marshalKey() {

		Key parent = null;

		ParentKeyMetadata parentKeyMetadata = entityMetadata.getParentKeyMetadata();
		if (parentKeyMetadata != null) {
			DatastoreKey parentDatastoreKey = (DatastoreKey) getFieldValue(parentKeyMetadata);
			if (parentDatastoreKey != null) {
				parent = parentDatastoreKey.nativeKey();
			}
		}

		IdentifierMetadata identifierMetadata = entityMetadata.getIdentifierMetadata();
		DataType identifierType = identifierMetadata.getDataType();
		Object idValue = getFieldValue(identifierMetadata);

		boolean validId = isValidId(idValue, identifierType);
		boolean autoGenerateId = identifierMetadata.isAutoGenerated();

		if (validId) {
			if (identifierType == DataType.STRING) {
				createCompleteKey(parent, (String) idValue);
			} else {
				createCompleteKey(parent, (long) idValue);
			}
		} else {
			if (doNotGenerateId) {
				throw new EntityManagerException(
						String.format("Identifier is not set or vlaid for entity of type %s", entity.getClass()));
			}
			if (!autoGenerateId) {
				throw new EntityManagerException(String.format(
						"Identifier is not set or vlaid for entity of type %s. Auto generation of ID is explicity turned off. ",
						entity.getClass()));
			} else {
				if (identifierType == DataType.STRING) {
					createCompleteKey(parent);
				} else {
					createIncompleteKey(parent);
				}
			}
		}
	}

	/**
	 * Checks to see if the given value is a valid identifier for the given ID
	 * type.
	 * 
	 * @param idValue
	 *            the ID value
	 * @param identifierType
	 *            the identifier type
	 * @return <code>true</code>, if the given value is a valid identifier;
	 *         <code>false</code>, otherwise. For STRING type, the ID is valid
	 *         if it it contains at least one printable character. In other
	 *         words, if ((String) idValue).trim().length() > 0. For numeric
	 *         types, the ID is valid if it is not <code>null</code> or zero.
	 */
	private static boolean isValidId(Object idValue, DataType identifierType) {
		boolean validId = false;
		if (idValue != null) {
			switch (identifierType) {
			case LONG:
			case LONG_OBJECT:
				validId = (long) idValue != 0;
				break;
			case STRING:
				validId = ((String) idValue).trim().length() > 0;
				break;
			default:
				// we should never get here
				break;
			}
		}
		return validId;
	}

	/**
	 * Creates a complete key using the given parameters.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 * @param id
	 *            the numeric ID
	 */
	private void createCompleteKey(Key parent, long id) {
		String kind = entityMetadata.getKind();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey(id);
		} else {
			key = Key.builder(parent, kind, id).build();
		}
	}

	/**
	 * Creates a complete key using the given parameters.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 * @param id
	 *            the String ID
	 */
	private void createCompleteKey(Key parent, String id) {
		String kind = entityMetadata.getKind();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey(id);
		} else {
			key = Key.builder(parent, kind, id).build();
		}
	}

	/**
	 * Creates a ComplteKey using the given parameters. The actual ID is
	 * generated using <code>UUID.randomUUID().toString()</code>.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 */
	private void createCompleteKey(Key parent) {
		String kind = entityMetadata.getKind();
		String id = UUID.randomUUID().toString();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey(id);
		} else {
			key = Key.builder(parent, kind, id).build();
		}
	}

	/**
	 * Creates an IncompleteKey.
	 * 
	 * @param parent
	 *            the parent key, may be <code>null</code>.
	 */
	private void createIncompleteKey(Key parent) {
		String kind = entityMetadata.getKind();
		if (parent == null) {
			key = datastore.newKeyFactory().kind(kind).newKey();
		} else {
			key = IncompleteKey.builder(parent, kind).build();
		}
	}

	/**
	 * Marshals all the fields.
	 */
	private void marshalFields() {
		Collection<PropertyMetadata> propertyMetadataCollection = entityMetadata.getPropertyMetadataCollection();
		for (PropertyMetadata propertyMetadata : propertyMetadataCollection) {
			marshalField(propertyMetadata, entity);
		}
	}

	/**
	 * Marshals the field with the given property metadata.
	 * 
	 * @param propertyMetadata
	 *            the metadata of the field to be marshaled.
	 * @param target
	 *            the object in which the field is defined/accessible from.
	 */
	private void marshalField(PropertyMetadata propertyMetadata, Object target) {
		marshalField(propertyMetadata, target, entityBuilder);
	}

	/**
	 * Marshals the field with the given property metadata.
	 * 
	 * @param propertyMetadata
	 *            the metadata of the field to be marshaled.
	 * @param target
	 *            the object in which the field is defined/accessible from
	 * @param entityBuilder
	 *            the native entity on which the marshaled field should be set
	 */
	private static void marshalField(PropertyMetadata propertyMetadata, Object target,
			BaseEntity.Builder<?, ?> entityBuilder) {
		Object fieldValue = getFieldValue(propertyMetadata, target);
		ValueBuilder<?, ?, ?> valueBuilder;
		if (fieldValue == null) {
			valueBuilder = NullValue.builder();
		} else {
			PropertyConverter converter = propertyMetadata.getDataType().getConverter();
			valueBuilder = converter.toValueBuilder(fieldValue, propertyMetadata);
		}
		valueBuilder.excludeFromIndexes(!propertyMetadata.isIndexed());
		Value<?> datastoreValue = valueBuilder.build();
		entityBuilder.set(propertyMetadata.getMappedName(), datastoreValue);
	}

	/**
	 * Returns the value for the given field of the entity being marshaled.
	 *
	 * @param fieldMetadata
	 *            the field's metadata
	 * @return the field's value
	 */
	private Object getFieldValue(FieldMetadata fieldMetadata) {
		return getFieldValue(fieldMetadata, entity);
	}

	/**
	 * Returns the value of the field represented by the given metadata.
	 * 
	 * @param fieldMetadata
	 *            the metadata of the field
	 * @param target
	 *            the target object to which the field belongs.
	 * @return the value of the field.
	 */
	private static Object getFieldValue(FieldMetadata fieldMetadata, Object target) {
		Method readMethod = fieldMetadata.getReadMethod();
		try {
			return readMethod.invoke(target);
		} catch (Exception exp) {
			throw new EntityManagerException(exp.getMessage(), exp);
		}
	}

	/**
	 * Marshals the embedded fields.
	 */
	private void marshalEmbeddedFields() {
		for (EmbeddedMetadata embeddedMetadata : entityMetadata.getEmbeddedMetadataCollection()) {
			if (embeddedMetadata.getStorageStrategy() == StorageStrategy.EXPLODED) {
				marshalWithExplodedStrategy(embeddedMetadata, entity);
			} else {
				ValueBuilder<?, ?, ?> embeddedEntityBuilder = marshalWithImplodedStrategy(embeddedMetadata, entity);
				entityBuilder.set(embeddedMetadata.getMappedName(), embeddedEntityBuilder.build());
			}
		}

	}

	/**
	 * Marshals an embedded field represented by the given metadata.
	 * 
	 * @param embeddedMetadata
	 *            the metadata of the embedded field
	 * @param target
	 *            the target object to which the embedded object belongs
	 */
	private void marshalWithExplodedStrategy(EmbeddedMetadata embeddedMetadata, Object target) {
		try {
			Object embeddedObject = IntrospectionUtils.initializeEmbedded(embeddedMetadata, target);
			for (PropertyMetadata propertyMetadata : embeddedMetadata.getPropertyMetadataCollection()) {
				marshalField(propertyMetadata, embeddedObject);
			}
			for (EmbeddedMetadata embeddedMetadata2 : embeddedMetadata.getEmbeddedMetadataCollection()) {
				marshalWithExplodedStrategy(embeddedMetadata2, embeddedObject);
			}
		} catch (Exception exp) {
			throw new EntityManagerException(exp);
		}
	}

	/**
	 * Marshals the embedded field represented by the given metadata.
	 * 
	 * @param embeddedMetadata
	 *            the metadata of the embedded field.
	 * @param target
	 *            the object in which the embedded field is defined/accessible
	 *            from.
	 * @return the ValueBuilder equivalent to embedded object
	 */
	private ValueBuilder<?, ?, ?> marshalWithImplodedStrategy(EmbeddedMetadata embeddedMetadata, Object target) {
		try {
			Object embeddedObject = embeddedMetadata.getReadMethod().invoke(target);
			if (embeddedObject == null) {
				NullValue.Builder nullValueBuilder = NullValue.builder();
				nullValueBuilder.excludeFromIndexes(!embeddedMetadata.isIndexed());
				return nullValueBuilder;
			}
			FullEntity.Builder<IncompleteKey> embeddedEntityBuilder = FullEntity.builder();
			for (PropertyMetadata propertyMetadata : embeddedMetadata.getPropertyMetadataCollection()) {
				marshalField(propertyMetadata, embeddedObject, embeddedEntityBuilder);
			}
			for (EmbeddedMetadata embeddedMetadata2 : embeddedMetadata.getEmbeddedMetadataCollection()) {
				ValueBuilder<?, ?, ?> embeddedEntityBuilder2 = marshalWithImplodedStrategy(embeddedMetadata2,
						embeddedObject);
				embeddedEntityBuilder.set(embeddedMetadata2.getMappedName(), embeddedEntityBuilder2.build());
			}
			EntityValue.Builder valueBuilder = EntityValue.builder(embeddedEntityBuilder.build());
			valueBuilder.excludeFromIndexes(!embeddedMetadata.isIndexed());
			return valueBuilder;

		} catch (Exception exp) {
			throw new EntityManagerException(exp);
		}

	}

}
